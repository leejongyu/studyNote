Stream :  array 또는 collection 객체에 저장된 원소들을 처리하는 코드패턴.
         > 람다표현식을 사용하여 객체의 원소에 대한 처리할 수 있음
          
1. Stream 정의 : 데이터 처리연산을 지원하도록 소스에서 추출된 연속된 요소
  ? 데이터 처리 연산: 스트림은 함수형 프로그래밍에서 지원하는 연산과 데이터베이스의 SQL 질의형과 비슷한 연산을 처리할 수 있다.
  ? 소스 : 스트림은 컬렉션, 배열, I/O 자원등의 소스로부터 데이터를 소비하고 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다. 
          즉 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.
  ? 연속된 요소 : 컬렉션 자료구조와 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
                 컬렉션에서는 시간, 공간의 복잡성과 관련된 요소의 저장 및 연산이 이루어진다면 스트림에서는 filter, sorted, map 처럼 표현 계산식으로 이루어져 있다.
                 즉 컬렉션의 주제는 데이터, 스트림의 주제는 계산입니다.

2. Stream 특징
 1) Pipelining : 스트림 연산들은 서로 연결하여 큰 파이프 라인을 구성할수 있도록 스트림 자신을 반환한다. SQL 등 데이터베이스의 질의문과 비슷함 
 2) 내부 반복 : 반복자를 이용하여 명시적으로 반복하는 컬렉션과 다르게 스트림은 내부 반복 기능을 제공
 3) 반복의 일회성 : Stream에서는 소비의 개념을 사용하기 때문에, 한 번 처리한 반복문을 다시 실행하면 에러가 발생.

3. Stream 연산
 1) 중간연산 : 파이프라인으로 연결할 수 있는 연산들
               중간연산은 다른 스트림을 반환하기 때문에 여러개의 중간연산을 연결하여 query를 만들 수 있다. 최종연산을 실행하기 전까지는 아무런 연산을 수행하지 않는다.
              > filter(), map(), limit() 등
 2) 최종연산 : 파이프라인을 실행한 다음 닫는 연산
               파이프라인 연산의 결과를 출력.
              > collect()
 
4. Stream 생성  
  1) Collection.stream()
   > 컬렉션 객체들이 갖고 있는 .stream() 메서드를 호출하여 객체를 생성
    > Stream<Collection 객체에 저장된 원소의 데이터 타입> stream이름 = collection객체이름.stream();
    > List<Integer> list = new ArrayList<>():
      Stream<Integer> collectionStream = list.stream();
  
  2) Array.stream()
   > Arrays가 가진 .stream() 메서드를 호출하여 객체를 생성
    > Stram<array 객체에 저장된 원소의 데이터 타입> stream이름 = Arrays.stream(array이름);
    > Integer[] array = new Integer[int i];
      Stream<Integer> arrayStream = Arrays.stream(array);
  
  3) Empty Stream
   > Stream 객체를 참조하는 변수가 null일 경우, NullPointException이 발생할 수 있는데, 이 경우에 사용
    > Stream<데이터타입> stream이름 = Stream.empty();
    > Stream<Integer> emptyStream = Stream.empty();
    
  4) Stream.builder()
   > 배열, 컬렉션 등을 통해서 생성하는것이 아니라 직접 값을 입력해서 객체를 생성
    > Stream<입력할 값들의 데이터타입> stream이름 = Stream<데이터타입>builder().add(데이터).add(데이터)......build();
    > Stream<Integer> streamBuilder = Stream<Integer>builfer().add(1).add(2).add(3).build();
    
  5) Stream.generate()
   > 데이터를 생성하는 람다식을 이용하여 스트림을 생성할 수 있다.
   > 이 과정에서는 Supplier에 해당하는 람다로 값을 넣을 수 있다.
    >> Sulpplier ? 매개변수는 없고, 리턴 값만 있는 인터페이스. 
    >>> Supplier<String> abcSupplier = () -> "abc" ;
        sysout(abcSupplier.get()); = > "abc"를 출력
   > limit() 메서드를 사용하지 않으면 데이터를 무한대로 생성하기 때문에 limit을 주어야 함
   > Stream<데이터타입> stream이름 = Stream.generate( () -> "데이터".limit(0 이상의 정수);
   > Stream<Integer> streamGenerate = Stream.generate( () -> 123.limit(3); => 123이 3번 저장된 stream 생성











ref
 > https://ksr930.tistory.com/237/
 > https://hbase.tistory.com/171/
 > https://futurecreator.github.io/2018/08/26/java-8-streams/
